using SecureStorage;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using System.Runtime.CompilerServices;
using static CloudSync.Util;

namespace CloudSync
{
    public class RoleManager
    {
        public RoleManager(Sync sync)
        {
            Sync = sync;
            LoadAll();
        }

        private readonly Sync Sync;

        public readonly Dictionary<ulong, Client> Clients = new Dictionary<ulong, Client>();
        public readonly Dictionary<ulong, Client> TmpClients = new Dictionary<ulong, Client>();
        public List<Client> ClientsConnected()
        {
            var clients = new List<Client>();
            foreach (var client in Clients.Values)
            {
                if (client.IsConnected)
                    clients.Add(client);
            }
            ; return clients;
        }

        private bool? _MasterPinEnabled;
        /// <summary>
        /// If set to False, disables PIN authentication (temporary file sharing PINs will still work)
        /// If disabled, authentication is only available via 2FA.
        /// </summary>
        public bool MasterPinEnabled
        {
            get
            {
                if (_MasterPinEnabled == null)
                    _MasterPinEnabled = Sync.SecureStorage.Values.Get(nameof(MasterPinEnabled), true);
                return (bool)_MasterPinEnabled;
            }
            set { Sync.SecureStorage.Values.Set(nameof(MasterPinEnabled), value); }
        }

        /// <summary>
        /// The string to display as a QR code to set up 2FA
        /// </summary>
        /// <returns>2FA QR Code setting string</returns>
        public string QrCode2FA()
        {
            var twoFactorAuth = new TwoFactorAuth(Sync.SecureStorage);
            return twoFactorAuth.QRCodeUri();
        }

        /// <summary>
        /// Change 2FA key (you will need to reset a new authentication device via QR code)
        /// </summary>
        public void Reset2FA()
        {
            var twoFactorAuth = new TwoFactorAuth(Sync.SecureStorage);
            twoFactorAuth.ResetSecretKey();
        }

        /// <summary>
        /// The server initiate an authentication request for new client and send it (Function callable only by the server)
        /// </summary>
        /// <param name="clientPubKey">The publicKey/ID of the client, which is used to authenticate the client-side request</param>
        /// <param name="sendRequestOfValidationToClient">The action to send the validation request to the client</param>
        /// <param name="host">Non-TrustLess information as the proxy or whoever generates this data could falsify it. It is logged for access log purposes</param>
        /// <param name="userAgent">Non-TrustLess information as the proxy or whoever generates this data could falsify it. It is logged for access log purposes</param>
        public void LoginRequest(Action<Client, byte[]> sendRequestOfValidationToClient, byte[] clientPubKey = null, ulong? id = null, string host = null, string userAgent = null, int? chunkSizeSetting = null, short thumbnailSize = 0)
        {
#if DEBUG
            if (!Sync.IsServer)
                System.Diagnostics.Debugger.Break();
#endif 

            var isRestApiClient = clientPubKey != null; // True if the client is using the encrypted rest api protocol, designed for use by JavaScript/browser

            if (clientPubKey != null && id == null)
                id = PublicKeyToUserId(clientPubKey);
            var pins = GetPins(Sync.SecureStorage);
            if (pins == null || pins.Count == 0)
                return;
            var randomBitesForAuthenticationProof = new byte[32];
            new Random().NextBytes(randomBitesForAuthenticationProof);
            var authenticationProof = CryptographicProofOfPinKnowledge(randomBitesForAuthenticationProof, pins, isRestApiClient);
            if (TryToGetClient((ulong)id, out var client, out var isTemp))
            {
                if (!isTemp)
                {
                    client.AddNewAccess(host, userAgent);
                }
                client.SetAuthenticationProof(authenticationProof);
            }
            else
            {
                if (isRestApiClient)
                {
                    var generateAesKey = (userAgent != null && userAgent.Contains("Mozilla/")); // If it is a browser then it communicates encrypted with the generated AES keys, while for react applications it uses xorAB encryption using the key generated by the client
                                                                                                // =====================
                                                                                                // generateAesKey = false;
                                                                                                // =====================
                    client = new Client(Sync, clientPubKey, authenticationProof, host, userAgent, generateAesKey);
                }
                else
                    client = new Client(Sync, (ulong)id, authenticationProof, host, userAgent);
            }
            client.ChunkSize = chunkSizeSetting == 0 ? null : chunkSizeSetting;
            client.ThumbnailSize = thumbnailSize;
            sendRequestOfValidationToClient(client, randomBitesForAuthenticationProof);
        }

        internal static ProofOfPin CryptographicProofOfPinKnowledge(byte[] randomBitesForAuthenticationProof, IEnumerable<OneTimeAccess> pins, bool isRestApiClient)
        {
            return new ProofOfPin()
            {
                IsRestApiClient = isRestApiClient,
                RandomBitesForAuthenticationProof = randomBitesForAuthenticationProof,
                Pins = pins
            };
        }


        public class ProofOfPin
        {
            internal bool IsRestApiClient;
            internal byte[] RandomBitesForAuthenticationProof;
            internal IEnumerable<OneTimeAccess> Pins;
            public bool Validate(string cloudRoot, uint ProofOfPinKnowledge, out string pin, out string label, out string group)
            {
                foreach (var p in Pins)
                {
                    var Proof = CryptographicProofOfPinKnowledge(RandomBitesForAuthenticationProof, p.Pin);
                    if (Proof == ProofOfPinKnowledge)
                    {
                        pin = p.Pin;
                        label = p.Label;
                        group = null;
                        return true;
                    }
                }
                // Check if the pin is for a file sharing group
                if (IsRestApiClient)
                {
                    foreach (var g in Share.GetGroups(cloudRoot))
                    {
                        foreach (var p in Share.GetPins(cloudRoot, g))
                        {
                            var Proof = CryptographicProofOfPinKnowledge(RandomBitesForAuthenticationProof, p);
                            if (Proof == ProofOfPinKnowledge)
                            {
                                pin = p;
                                label = "File sharing group " + g;
                                group = g;
                                return true;
                            }
                        }
                    }
                }
                group = null;
                pin = null;
                label = null;
                return false;
            }
        }

        internal static uint CryptographicProofOfPinKnowledge(byte[] randomBitesForAuthenticationProof, string pin)
        {
            byte[] pinBytes = int.TryParse(pin, out int pinInt) ? BitConverter.GetBytes(pinInt) : (new byte[0]);
            var baseHash = new byte[randomBitesForAuthenticationProof.Length + pinBytes.Length];
            randomBitesForAuthenticationProof.CopyTo(baseHash, 0);
            pinBytes.CopyTo(baseHash, randomBitesForAuthenticationProof.Length);
            //var baseHash = randomBitesForAuthenticationProof.Combine(BitConverter.GetBytes(int.Parse(pin)));
            var hash = Hash256(baseHash);
            return BitConverter.ToUInt32(hash, 0);
        }

        internal static ulong PublicKeyToUserId(byte[] publicKey)
        {
            var clientId = Hash256(publicKey).Take(8).ToArray();
            return BitConverter.ToUInt64(clientId, 0);
        }

        public bool TryToGetClient(ulong id, out Client client, out bool isTemp)
        {
            if (TmpClients.TryGetValue(id, out client))
            {
                client.LastInteraction = DateTime.UtcNow;
                isTemp = true;
                return true;
            }
            if (Clients.TryGetValue(id, out client))
            {
                client.LastInteraction = DateTime.UtcNow;
                isTemp = false;
                return true;
            }
            client = null;
            isTemp = false;
            return false;
        }

        public void LoadAll()
        {
            var objs = Sync.SecureStorage.ObjectStorage.GetAllObjects(typeof(Client));
            foreach (var obj in objs)
            {
                var client = obj as Client;
                client.Sync = Sync;
                Clients[client.Id] = client;
            }
        }


    }
}
